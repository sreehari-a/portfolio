{"version":3,"file":"static/js/404.129f8697.chunk.js","mappings":"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","sources":["utils/checkStore.js","utils/reducerInjectors.js","utils/injectReducer.js","utils/constants.js","utils/sagaInjectors.js","utils/injectSaga.js","HomePage/constants.js","HomePage/reducer.js","HomePage/saga.js","App/constants.js","HomePage/index.js","HomePage/styles.js"],"sourcesContent":["import { conformsTo, isFunction, isObject } from 'lodash';\r\nimport invariant from 'invariant';\r\n\r\n/**\r\n * Validate the shape of redux store\r\n */\r\nexport default function checkStore(store) {\r\n  const shape = {\r\n    dispatch: isFunction,\r\n    subscribe: isFunction,\r\n    getState: isFunction,\r\n    replaceReducer: isFunction,\r\n    runSaga: isFunction,\r\n    injectedReducers: isObject,\r\n    injectedSagas: isObject,\r\n  };\r\n  invariant(\r\n    conformsTo(store, shape),\r\n    '(app/utils...) injectors: Expected a valid redux store',\r\n  );\r\n}\r\n","import invariant from 'invariant';\r\nimport { isEmpty, isFunction, isString } from 'lodash';\r\n\r\nimport checkStore from './checkStore';\r\nimport createReducer from '../reducers';\r\n\r\nexport function injectReducerFactory(store, isValid) {\r\n  return function injectReducer(key, reducer) {\r\n    if (!isValid) checkStore(store);\r\n\r\n    invariant(\r\n      isString(key) && !isEmpty(key) && isFunction(reducer),\r\n      '(app/utils...) injectReducer: Expected `reducer` to be a reducer function',\r\n    );\r\n\r\n    // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\r\n    if (\r\n      Reflect.has(store.injectedReducers, key) &&\r\n      store.injectedReducers[key] === reducer\r\n    )\r\n      return;\r\n\r\n    store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\r\n    store.replaceReducer(createReducer(store.injectedReducers));\r\n  };\r\n}\r\n\r\nexport default function getInjectors(store) {\r\n  checkStore(store);\r\n\r\n  return {\r\n    injectReducer: injectReducerFactory(store, true),\r\n  };\r\n}\r\n","import React from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { ReactReduxContext } from 'react-redux';\r\n\r\nimport getInjectors from './reducerInjectors';\r\n\r\n/**\r\n * Dynamically injects a reducer\r\n *\r\n * @param {string} key A key of the reducer\r\n * @param {function} reducer A reducer that will be injected\r\n *\r\n */\r\nexport default ({ key, reducer }) => WrappedComponent => {\r\n  class ReducerInjector extends React.Component {\r\n    static WrappedComponent = WrappedComponent;\r\n\r\n    static contextType = ReactReduxContext;\r\n\r\n    static displayName = `withReducer(${WrappedComponent.displayName ||\r\n      WrappedComponent.name ||\r\n      'Component'})`;\r\n\r\n    constructor(props, context) {\r\n      super(props, context);\r\n\r\n      getInjectors(context.store).injectReducer(key, reducer);\r\n    }\r\n\r\n    render() {\r\n      return <WrappedComponent {...this.props} />;\r\n    }\r\n  }\r\n\r\n  return hoistNonReactStatics(ReducerInjector, WrappedComponent);\r\n};\r\n\r\nconst useInjectReducer = ({ key, reducer }) => {\r\n  const context = React.useContext(ReactReduxContext);\r\n  React.useEffect(() => {\r\n    getInjectors(context.store).injectReducer(key, reducer);\r\n  }, []);\r\n};\r\n\r\nexport { useInjectReducer };\r\n","export const RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\r\nexport const DAEMON = '@@saga-injector/daemon';\r\nexport const ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';\r\n","import invariant from 'invariant';\r\nimport { isEmpty, isFunction, isString, conformsTo } from 'lodash';\r\n\r\nimport checkStore from './checkStore';\r\nimport { DAEMON, ONCE_TILL_UNMOUNT, RESTART_ON_REMOUNT } from './constants';\r\n\r\nconst allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\r\n\r\nconst checkKey = key =>\r\n  invariant(\r\n    isString(key) && !isEmpty(key),\r\n    '(app/utils...) injectSaga: Expected `key` to be a non empty string',\r\n  );\r\n\r\nconst checkDescriptor = descriptor => {\r\n  const shape = {\r\n    saga: isFunction,\r\n    mode: mode => isString(mode) && allowedModes.includes(mode),\r\n  };\r\n  invariant(\r\n    conformsTo(descriptor, shape),\r\n    '(app/utils...) injectSaga: Expected a valid saga descriptor',\r\n  );\r\n};\r\n\r\nexport function injectSagaFactory(store, isValid) {\r\n  return function injectSaga(key, descriptor = {}, args) {\r\n    if (!isValid) checkStore(store);\r\n\r\n    const newDescriptor = {\r\n      ...descriptor,\r\n      mode: descriptor.mode || DAEMON,\r\n    };\r\n    const { saga, mode } = newDescriptor;\r\n\r\n    checkKey(key);\r\n    checkDescriptor(newDescriptor);\r\n\r\n    let hasSaga = Reflect.has(store.injectedSagas, key);\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      const oldDescriptor = store.injectedSagas[key];\r\n      // enable hot reloading of daemon and once-till-unmount sagas\r\n      if (hasSaga && oldDescriptor.saga !== saga) {\r\n        oldDescriptor.task.cancel();\r\n        hasSaga = false;\r\n      }\r\n    }\r\n\r\n    if (\r\n      !hasSaga ||\r\n      (hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT)\r\n    ) {\r\n      /* eslint-disable no-param-reassign */\r\n      store.injectedSagas[key] = {\r\n        ...newDescriptor,\r\n        task: store.runSaga(saga, args),\r\n      };\r\n      /* eslint-enable no-param-reassign */\r\n    }\r\n  };\r\n}\r\n\r\nexport function ejectSagaFactory(store, isValid) {\r\n  return function ejectSaga(key) {\r\n    if (!isValid) checkStore(store);\r\n\r\n    checkKey(key);\r\n\r\n    if (Reflect.has(store.injectedSagas, key)) {\r\n      const descriptor = store.injectedSagas[key];\r\n      if (descriptor.mode && descriptor.mode !== DAEMON) {\r\n        descriptor.task.cancel();\r\n        // Clean up in production; in development we need `descriptor.saga` for hot reloading\r\n        if (process.env.NODE_ENV === 'production') {\r\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\r\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n\r\nexport default function getInjectors(store) {\r\n  checkStore(store);\r\n\r\n  return {\r\n    injectSaga: injectSagaFactory(store, true),\r\n    ejectSaga: ejectSagaFactory(store, true),\r\n  };\r\n}\r\n","import React from 'react';\r\nimport hoistNonReactStatics from 'hoist-non-react-statics';\r\nimport { ReactReduxContext } from 'react-redux';\r\n\r\nimport getInjectors from './sagaInjectors';\r\n\r\n/**\r\n * Dynamically injects a saga, passes component's props as saga arguments\r\n *\r\n * @param {string} key A key of the saga\r\n * @param {function} saga A root saga that will be injected\r\n * @param {string} [mode] By default (constants.DAEMON) the saga will be started\r\n * on component mount and never canceled or started again. Another two options:\r\n *   - constants.RESTART_ON_REMOUNT — the saga will be started on component mount and\r\n *   cancelled with `task.cancel()` on component unmount for improved performance,\r\n *   - constants.ONCE_TILL_UNMOUNT — behaves like 'RESTART_ON_REMOUNT' but never runs it again.\r\n *\r\n */\r\nexport default ({ key, saga, mode }) => WrappedComponent => {\r\n  class InjectSaga extends React.Component {\r\n    static WrappedComponent = WrappedComponent;\r\n\r\n    static contextType = ReactReduxContext;\r\n\r\n    static displayName = `withSaga(${WrappedComponent.displayName ||\r\n      WrappedComponent.name ||\r\n      'Component'})`;\r\n\r\n    constructor(props, context) {\r\n      super(props, context);\r\n\r\n      this.injectors = getInjectors(context.store);\r\n\r\n      this.injectors.injectSaga(key, { saga, mode }, this.props);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      this.injectors.ejectSaga(key);\r\n    }\r\n\r\n    render() {\r\n      return <WrappedComponent {...this.props} />;\r\n    }\r\n  }\r\n\r\n  return hoistNonReactStatics(InjectSaga, WrappedComponent);\r\n};\r\n\r\nconst useInjectSaga = ({ key, saga, mode }) => {\r\n  const context = React.useContext(ReactReduxContext);\r\n  React.useEffect(() => {\r\n    const injectors = getInjectors(context.store);\r\n    injectors.injectSaga(key, { saga, mode });\r\n\r\n    return () => {\r\n      injectors.ejectSaga(key);\r\n    };\r\n  }, []);\r\n};\r\n\r\nexport { useInjectSaga };\r\n","/*\n * HomeConstants\n * Each action has a corresponding type, which the reducer knows and picks up on.\n * To avoid weird typos between the reducer and the actions, we save them as\n * constants here. We prefix them with 'yourproject/YourComponent' so we avoid\n * reducers accidentally picking up actions they shouldn't.\n *\n * Follow this format:\n * export const YOUR_ACTION_CONSTANT = 'yourproject/YourContainer/YOUR_ACTION_CONSTANT';\n */\n\nexport const CHANGE_USERNAME = 'boilerplate/Home/CHANGE_USERNAME';\n","/*\n * HomeReducer\n *\n * The reducer takes care of our data. Using actions, we can\n * update our application state. To add a new action,\n * add it to the switch statement in the reducer function\n *\n */\n\nimport produce from 'immer';\nimport { CHANGE_USERNAME } from './constants';\n\n// The initial state of the App\nexport const initialState = {\n  username: '',\n};\n\n/* eslint-disable default-case, no-param-reassign */\nconst homeReducer = (state = initialState, action) =>\n  produce(state, draft => {\n    switch (action.type) {\n      case CHANGE_USERNAME:\n        // Delete prefixed '@' from the github username\n        draft.username = action.username.replace(/@/gi, '');\n        break;\n    }\n  });\n\nexport default homeReducer;\n","/**\n * Gets the repositories of the user from Github\n */\n\nimport { call, put, select, takeLatest } from 'redux-saga/effects';\nimport { LOAD_REPOS } from '../App/constants';\nimport { reposLoaded, repoLoadingError } from '../App/actions';\n\n// import request from '../../utils/request';\nimport { makeSelectUsername } from './selectors';\n\n/**\n * Github repos request/response handler\n */\nexport function* getRepos() {\n  // Select username from store\n  // const username = yield select(makeSelectUsername());\n  // const requestURL = `https://api.github.com/users/${username}/repos?type=all&sort=updated`;\n\n  // try {\n  //   // Call our request helper (see 'utils/request')\n  //   const repos = yield call(request, requestURL);\n  //   yield put(reposLoaded(repos, username));\n  // } catch (err) {\n  //   yield put(repoLoadingError(err));\n  // }\n}\n\n/**\n * Root saga manages watcher lifecycle\n */\nexport default function* githubData() {\n  // Watches for LOAD_REPOS actions and calls getRepos when one comes in.\n  // By using `takeLatest` only the result of the latest API call is applied.\n  // It returns task descriptor (just like fork) so we can continue execution\n  // It will be cancelled automatically on component unmount\n  yield takeLatest(LOAD_REPOS, getRepos);\n}\n","/*\n * AppConstants\n * Each action has a corresponding type, which the reducer knows and picks up on.\n * To avoid weird typos between the reducer and the actions, we save them as\n * constants here. We prefix them with 'yourproject/YourComponent' so we avoid\n * reducers accidentally picking up actions they shouldn't.\n *\n * Follow this format:\n * export const YOUR_ACTION_CONSTANT = 'yourproject/YourContainer/YOUR_ACTION_CONSTANT';\n */\n\nexport const LOAD_REPOS = 'boilerplate/App/LOAD_REPOS';\nexport const LOAD_REPOS_SUCCESS = 'boilerplate/App/LOAD_REPOS_SUCCESS';\nexport const LOAD_REPOS_ERROR = 'boilerplate/App/LOAD_REPOS_ERROR';\n","/*\n * HomePage\n *\n * This is the first thing users see of our App, at the '/' route\n */\n\nimport React, { memo } from \"react\";\nimport { compose } from \"redux\";\n\nimport { useInjectReducer } from \"../utils/injectReducer\";\nimport { useInjectSaga } from \"../utils/injectSaga\";\nimport reducer from \"./reducer\";\nimport saga from \"./saga\";\nimport stylize from \"../utils/stylize\";\nimport styles from \"./styles\";\n\nconst key = \"home\";\n\nexport function HomePage({ classes }) {\n  useInjectReducer({ key, reducer });\n  useInjectSaga({ key, saga });\n\n  return (\n    <div className={classes.warningMessage}>\n      Currently under Maintenance. Will be back soon\n    </div>\n  );\n}\n\nexport default compose(memo)(stylize(HomePage, styles));\n","export default function styles() {\n  return {\n    warningMessage: {\n      margin: 'auto',\n      fontSize: '30px',\n      zIndex: 1,\n      paddingBottom: '12rem',\n      fontFamily: 'cursive',\n      animationDuration: '2s',\n      animationName: '$animatePop',\n      animationTimingFunction: 'cubic-bezier(.26, .53, .74, 1.48)',\n    },\n    '@keyframes animatePop': {\n      '0%': {\n        opacity: 0,\n        transform: 'scale(0.5, 0.5)',\n      },\n\n      '100%': {\n        opacity: 1,\n        transform: 'scale(1, 1)',\n      },\n    },\n  };\n}\n"],"names":["checkStore","store","shape","dispatch","isFunction","subscribe","getState","replaceReducer","runSaga","injectedReducers","isObject","injectedSagas","invariant","conformsTo","injectReducerFactory","isValid","key","reducer","isString","isEmpty","Reflect","has","createReducer","useInjectReducer","context","React","ReactReduxContext","injectReducer","DAEMON","ONCE_TILL_UNMOUNT","allowedModes","checkKey","checkDescriptor","descriptor","saga","mode","includes","injectSagaFactory","args","newDescriptor","hasSaga","task","ejectSagaFactory","cancel","useInjectSaga","injectors","injectSaga","ejectSaga","CHANGE_USERNAME","initialState","username","state","action","produce","draft","type","replace","getRepos","githubData","takeLatest","HomePage","classes","className","warningMessage","compose","memo","stylize","margin","fontSize","zIndex","paddingBottom","fontFamily","animationDuration","animationName","animationTimingFunction","opacity","transform"],"sourceRoot":""}